---
title: "Google C++ 代码风格入门"
tags: Google C++ code-style
---

## 前言

这篇文章是针对像我一样非科班的编程爱好者，写着C style的C++代码但是想了解一些代码规范。这里摘抄了一些我认为平时用的到的、不涉及C++高级特性的Google代码风格规定，以供想快速了解的同学参考。
<!--more-->
当然你也可以通过点击[Google C++ 风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)来了解到完整的风格指南。

## Google代码风格窥探

*（注：Google的C++文件的后缀名通常为.cc）*

### 头文件

#### define 保护
   
  > 所有头文件都应该使用 **#define** 来防止头文件被多重包含, 命名格式当是: \<PROJECT\>\_\<PATH\>\_\<FILE\>\_H_ .

  为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护:
  ```c++
  #ifndef FOO_BAR_BAZ_H_
  #define FOO_BAR_BAZ_H_
  ...
  #endif // FOO_BAR_BAZ_H_
  ```

#### 内联函数

  > 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

  一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

  另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

#### #include 的路径及顺序

  > 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.

  举例来说，倘若**dir/foo.cc**或**dir/foo_test.cc**的主要作用是实现或测试 **dir2/foo2.h** 的功能, **foo.cc**中包含头文件的次序如下:

  1. dir2/foo2.h (优先位置, 详情如下)
  2. C 系统文件
  3. C++ 系统文件
  4. 其他库的 .h 文件
  5. 本项目内 .h 文件

  这种优先的顺序排序保证当 **dir2/foo2.h** 遗漏某些必要的库时， **dir/foo.cc** 或 **dir/foo_test.cc** 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

  *（注：大意就是说，按照这个顺序当foo2.h遗漏库时会第一时间报错，但如果把其他头文件放在前面，则报错时优先报其他头文件的遗漏库的信息。）*

### 作用域

#### <span id="namespace">命名空间</span>

> 鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。

**定义**：命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.

**结论**：根据下文将要提到的策略合理使用命名空间.
  - 遵守 **命名空间命名** 中的规则。
  - 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。
  - 用命名空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间。
  - 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。
    ```cpp
    // 在 .cc 中使用别名缩短常用的命名空间
    namespace baz = ::foo::bar::baz;
    ```
  - 不应该使用 using 指示 引入整个命名空间的标识符号。
    ```cpp
    // 禁止 —— 污染命名空间
    using namespace foo;
    ```

#### 非成员函数、静态成员函数和全局函数

> 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.

有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 [命名空间](#namespace) 。举例而言，对于头文件 myproject/foo_bar.h , 应当使用
```cpp
namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject
```

```cpp
namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject
```

#### 局部变量

> 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.

C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:

```cpp
int i;
i = f(); // 坏——初始化和声明分离
```

```cpp
int j = g(); // 好——初始化时声明
```

```cpp
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);
```

```cpp
vector<int> v = {1, 2}; // 好——v 一开始就初始化
```

属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:

```cpp
while (const char* p = strchr(str, '/')) str = p + 1;
```

> warining: 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.

```cpp
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
```
在循环作用域外面声明这类变量要高效的多:
```cpp
Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```
